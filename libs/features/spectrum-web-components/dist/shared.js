/* Generated by Milo*/
/* eslint-disable */
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));

// node_modules/focus-visible/dist/focus-visible.js
var require_focus_visible = __commonJS({
  "node_modules/focus-visible/dist/focus-visible.js"(exports, module) {
    (function(global, factory) {
      typeof exports === "object" && typeof module !== "undefined" ? factory() : typeof define === "function" && define.amd ? define(factory) : factory();
    })(exports, function() {
      "use strict";
      function applyFocusVisiblePolyfill(scope) {
        var hadKeyboardEvent = true;
        var hadFocusVisibleRecently = false;
        var hadFocusVisibleRecentlyTimeout = null;
        var inputTypesAllowlist = {
          text: true,
          search: true,
          url: true,
          tel: true,
          email: true,
          password: true,
          number: true,
          date: true,
          month: true,
          week: true,
          time: true,
          datetime: true,
          "datetime-local": true
        };
        function isValidFocusTarget(el) {
          if (el && el !== document && el.nodeName !== "HTML" && el.nodeName !== "BODY" && "classList" in el && "contains" in el.classList) {
            return true;
          }
          return false;
        }
        function focusTriggersKeyboardModality(el) {
          var type = el.type;
          var tagName = el.tagName;
          if (tagName === "INPUT" && inputTypesAllowlist[type] && !el.readOnly) {
            return true;
          }
          if (tagName === "TEXTAREA" && !el.readOnly) {
            return true;
          }
          if (el.isContentEditable) {
            return true;
          }
          return false;
        }
        function addFocusVisibleClass(el) {
          if (el.classList.contains("focus-visible")) {
            return;
          }
          el.classList.add("focus-visible");
          el.setAttribute("data-focus-visible-added", "");
        }
        function removeFocusVisibleClass(el) {
          if (!el.hasAttribute("data-focus-visible-added")) {
            return;
          }
          el.classList.remove("focus-visible");
          el.removeAttribute("data-focus-visible-added");
        }
        function onKeyDown(e3) {
          if (e3.metaKey || e3.altKey || e3.ctrlKey) {
            return;
          }
          if (isValidFocusTarget(scope.activeElement)) {
            addFocusVisibleClass(scope.activeElement);
          }
          hadKeyboardEvent = true;
        }
        function onPointerDown(e3) {
          hadKeyboardEvent = false;
        }
        function onFocus(e3) {
          if (!isValidFocusTarget(e3.target)) {
            return;
          }
          if (hadKeyboardEvent || focusTriggersKeyboardModality(e3.target)) {
            addFocusVisibleClass(e3.target);
          }
        }
        function onBlur(e3) {
          if (!isValidFocusTarget(e3.target)) {
            return;
          }
          if (e3.target.classList.contains("focus-visible") || e3.target.hasAttribute("data-focus-visible-added")) {
            hadFocusVisibleRecently = true;
            window.clearTimeout(hadFocusVisibleRecentlyTimeout);
            hadFocusVisibleRecentlyTimeout = window.setTimeout(function() {
              hadFocusVisibleRecently = false;
            }, 100);
            removeFocusVisibleClass(e3.target);
          }
        }
        function onVisibilityChange(e3) {
          if (document.visibilityState === "hidden") {
            if (hadFocusVisibleRecently) {
              hadKeyboardEvent = true;
            }
            addInitialPointerMoveListeners();
          }
        }
        function addInitialPointerMoveListeners() {
          document.addEventListener("mousemove", onInitialPointerMove);
          document.addEventListener("mousedown", onInitialPointerMove);
          document.addEventListener("mouseup", onInitialPointerMove);
          document.addEventListener("pointermove", onInitialPointerMove);
          document.addEventListener("pointerdown", onInitialPointerMove);
          document.addEventListener("pointerup", onInitialPointerMove);
          document.addEventListener("touchmove", onInitialPointerMove);
          document.addEventListener("touchstart", onInitialPointerMove);
          document.addEventListener("touchend", onInitialPointerMove);
        }
        function removeInitialPointerMoveListeners() {
          document.removeEventListener("mousemove", onInitialPointerMove);
          document.removeEventListener("mousedown", onInitialPointerMove);
          document.removeEventListener("mouseup", onInitialPointerMove);
          document.removeEventListener("pointermove", onInitialPointerMove);
          document.removeEventListener("pointerdown", onInitialPointerMove);
          document.removeEventListener("pointerup", onInitialPointerMove);
          document.removeEventListener("touchmove", onInitialPointerMove);
          document.removeEventListener("touchstart", onInitialPointerMove);
          document.removeEventListener("touchend", onInitialPointerMove);
        }
        function onInitialPointerMove(e3) {
          if (e3.target.nodeName && e3.target.nodeName.toLowerCase() === "html") {
            return;
          }
          hadKeyboardEvent = false;
          removeInitialPointerMoveListeners();
        }
        document.addEventListener("keydown", onKeyDown, true);
        document.addEventListener("mousedown", onPointerDown, true);
        document.addEventListener("pointerdown", onPointerDown, true);
        document.addEventListener("touchstart", onPointerDown, true);
        document.addEventListener("visibilitychange", onVisibilityChange, true);
        addInitialPointerMoveListeners();
        scope.addEventListener("focus", onFocus, true);
        scope.addEventListener("blur", onBlur, true);
        if (scope.nodeType === Node.DOCUMENT_FRAGMENT_NODE && scope.host) {
          scope.host.setAttribute("data-js-focus-visible", "");
        } else if (scope.nodeType === Node.DOCUMENT_NODE) {
          document.documentElement.classList.add("js-focus-visible");
          document.documentElement.setAttribute("data-js-focus-visible", "");
        }
      }
      if (typeof window !== "undefined" && typeof document !== "undefined") {
        window.applyFocusVisiblePolyfill = applyFocusVisiblePolyfill;
        var event;
        try {
          event = new CustomEvent("focus-visible-polyfill-ready");
        } catch (error) {
          event = document.createEvent("CustomEvent");
          event.initCustomEvent("focus-visible-polyfill-ready", false, false, {});
        }
        window.dispatchEvent(event);
      }
      if (typeof document !== "undefined") {
        applyFocusVisiblePolyfill(document);
      }
    });
  }
});

// node_modules/@spectrum-web-components/shared/src/focusable-selectors.js
var e = ["button", "[focusable]", "[href]", "input", "label", "select", "textarea", "[tabindex]"];
var o = ':not([tabindex="-1"])';
var userFocusableSelector = e.join(`${o}, `) + o;
var focusableSelector = e.join(", ");

// node_modules/@spectrum-web-components/shared/src/first-focusable-in.js
var firstFocusableIn = (e3) => e3.querySelector(userFocusableSelector);
var firstFocusableSlottedIn = (e3) => e3.assignedElements().find((o3) => o3.matches(userFocusableSelector));

// node_modules/@spectrum-web-components/shared/src/focus-visible.js
var i = true;
try {
  document.body.querySelector(":focus-visible");
} catch (a) {
  i = false, Promise.resolve().then(() => __toESM(require_focus_visible(), 1));
}
var FocusVisiblePolyfillMixin = (a) => {
  var n4;
  const s = (l2) => {
    if (l2.shadowRoot == null || l2.hasAttribute("data-js-focus-visible"))
      return () => {
      };
    if (self.applyFocusVisiblePolyfill)
      self.applyFocusVisiblePolyfill(l2.shadowRoot), l2.manageAutoFocus && l2.manageAutoFocus();
    else {
      const e3 = () => {
        self.applyFocusVisiblePolyfill && l2.shadowRoot && self.applyFocusVisiblePolyfill(l2.shadowRoot), l2.manageAutoFocus && l2.manageAutoFocus();
      };
      return self.addEventListener("focus-visible-polyfill-ready", e3, { once: true }), () => {
        self.removeEventListener("focus-visible-polyfill-ready", e3);
      };
    }
    return () => {
    };
  }, o3 = Symbol("endPolyfillCoordination");
  class t3 extends a {
    constructor() {
      super(...arguments);
      this[n4] = null;
    }
    connectedCallback() {
      super.connectedCallback && super.connectedCallback(), i || requestAnimationFrame(() => {
        this[o3] == null && (this[o3] = s(this));
      });
    }
    disconnectedCallback() {
      super.disconnectedCallback && super.disconnectedCallback(), i || requestAnimationFrame(() => {
        this[o3] != null && (this[o3](), this[o3] = null);
      });
    }
  }
  return n4 = o3, t3;
};

// node_modules/@spectrum-web-components/shared/src/focusable.js
import { SpectrumElement as h } from "/libs/features/spectrum-web-components/dist/base.js";
import { property as l } from "/libs/features/spectrum-web-components/dist/base.js";
var u = Object.defineProperty;
var b = Object.getOwnPropertyDescriptor;
var n = (s, a, e3, t3) => {
  for (var i2 = t3 > 1 ? void 0 : t3 ? b(a, e3) : a, o3 = s.length - 1, r2; o3 >= 0; o3--)
    (r2 = s[o3]) && (i2 = (t3 ? r2(a, e3, i2) : r2(i2)) || i2);
  return t3 && i2 && u(a, e3, i2), i2;
};
function d() {
  return new Promise((s) => requestAnimationFrame(() => s()));
}
var Focusable = class extends FocusVisiblePolyfillMixin(h) {
  constructor() {
    super(...arguments);
    this.disabled = false;
    this.autofocus = false;
    this._tabIndex = 0;
    this.manipulatingTabindex = false;
    this._recentlyConnected = false;
  }
  get tabIndex() {
    if (this.focusElement === this) {
      const t3 = this.hasAttribute("tabindex") ? Number(this.getAttribute("tabindex")) : NaN;
      return isNaN(t3) ? -1 : t3;
    }
    const e3 = parseFloat(this.hasAttribute("tabindex") && this.getAttribute("tabindex") || "0");
    return this.disabled || e3 < 0 ? -1 : this.focusElement ? this.focusElement.tabIndex : e3;
  }
  set tabIndex(e3) {
    if (this.manipulatingTabindex) {
      this.manipulatingTabindex = false;
      return;
    }
    if (this.focusElement === this) {
      if (e3 !== this._tabIndex) {
        this._tabIndex = e3;
        const t3 = this.disabled ? "-1" : "" + e3;
        this.manipulatingTabindex = true, this.setAttribute("tabindex", t3);
      }
      return;
    }
    if (e3 === -1 ? this.addEventListener("pointerdown", this.onPointerdownManagementOfTabIndex) : (this.manipulatingTabindex = true, this.removeEventListener("pointerdown", this.onPointerdownManagementOfTabIndex)), e3 === -1 || this.disabled) {
      this.setAttribute("tabindex", "-1"), this.removeAttribute("focusable"), e3 !== -1 && this.manageFocusElementTabindex(e3);
      return;
    }
    this.setAttribute("focusable", ""), this.hasAttribute("tabindex") ? this.removeAttribute("tabindex") : this.manipulatingTabindex = false, this.manageFocusElementTabindex(e3);
  }
  onPointerdownManagementOfTabIndex() {
    this.tabIndex === -1 && setTimeout(() => {
      this.tabIndex = 0, this.focus({ preventScroll: true }), this.tabIndex = -1;
    });
  }
  async manageFocusElementTabindex(e3) {
    this.focusElement || await this.updateComplete, e3 === null ? this.focusElement.removeAttribute("tabindex") : this.focusElement.tabIndex = e3;
  }
  get focusElement() {
    throw new Error("Must implement focusElement getter!");
  }
  focus(e3) {
    this.disabled || !this.focusElement || (this.focusElement !== this ? this.focusElement.focus(e3) : HTMLElement.prototype.focus.apply(this, [e3]));
  }
  blur() {
    const e3 = this.focusElement || this;
    e3 !== this ? e3.blur() : HTMLElement.prototype.blur.apply(this);
  }
  click() {
    if (this.disabled)
      return;
    const e3 = this.focusElement || this;
    e3 !== this ? e3.click() : HTMLElement.prototype.click.apply(this);
  }
  manageAutoFocus() {
    this.autofocus && (this.dispatchEvent(new KeyboardEvent("keydown", { code: "Tab" })), this.focusElement.focus());
  }
  firstUpdated(e3) {
    super.firstUpdated(e3), (!this.hasAttribute("tabindex") || this.getAttribute("tabindex") !== "-1") && this.setAttribute("focusable", "");
  }
  update(e3) {
    e3.has("disabled") && this.handleDisabledChanged(this.disabled, e3.get("disabled")), super.update(e3);
  }
  updated(e3) {
    super.updated(e3), e3.has("disabled") && this.disabled && this.blur();
  }
  async handleDisabledChanged(e3, t3) {
    const i2 = () => this.focusElement !== this && typeof this.focusElement.disabled != "undefined";
    e3 ? (this.manipulatingTabindex = true, this.setAttribute("tabindex", "-1"), await this.updateComplete, i2() ? this.focusElement.disabled = true : this.setAttribute("aria-disabled", "true")) : t3 && (this.manipulatingTabindex = true, this.focusElement === this ? this.setAttribute("tabindex", "" + this._tabIndex) : this.removeAttribute("tabindex"), await this.updateComplete, i2() ? this.focusElement.disabled = false : this.removeAttribute("aria-disabled"));
  }
  async getUpdateComplete() {
    const e3 = await super.getUpdateComplete();
    return this._recentlyConnected && (this._recentlyConnected = false, await d(), await d()), e3;
  }
  connectedCallback() {
    super.connectedCallback(), this._recentlyConnected = true, this.updateComplete.then(() => {
      this.manageAutoFocus();
    });
  }
};
n([l({ type: Boolean, reflect: true })], Focusable.prototype, "disabled", 2), n([l({ type: Boolean })], Focusable.prototype, "autofocus", 2), n([l({ type: Number })], Focusable.prototype, "tabIndex", 1);

// node_modules/@spectrum-web-components/shared/src/get-active-element.js
var getActiveElement = (e3) => e3.getRootNode().activeElement;

// node_modules/@spectrum-web-components/shared/src/like-anchor.js
import { html as d2 } from "/libs/features/spectrum-web-components/dist/base.js";
import { property as o2 } from "/libs/features/spectrum-web-components/dist/base.js";
import { ifDefined as r } from "/libs/features/spectrum-web-components/dist/base.js";
var b2 = Object.defineProperty;
var g = Object.getOwnPropertyDescriptor;
var n2 = (s, e3, p2, l2) => {
  for (var t3 = l2 > 1 ? void 0 : l2 ? g(e3, p2) : e3, a = s.length - 1, i2; a >= 0; a--)
    (i2 = s[a]) && (t3 = (l2 ? i2(e3, p2, t3) : i2(t3)) || t3);
  return l2 && t3 && b2(e3, p2, t3), t3;
};
function LikeAnchor(s) {
  class e3 extends s {
    renderAnchor({ id: t3, className: a, ariaHidden: i2, labelledby: c, tabindex: u3, anchorContent: f = d2`<slot></slot>` }) {
      return d2`<a
                    id=${t3}
                    class=${r(a)}
                    href=${r(this.href)}
                    download=${r(this.download)}
                    target=${r(this.target)}
                    aria-label=${r(this.label)}
                    aria-labelledby=${r(c)}
                    aria-hidden=${r(i2 ? "true" : void 0)}
                    tabindex=${r(u3)}
                    rel=${r(this.rel)}
                >${f}</a>`;
    }
  }
  return n2([o2({ reflect: true })], e3.prototype, "download", 2), n2([o2()], e3.prototype, "label", 2), n2([o2({ reflect: true })], e3.prototype, "href", 2), n2([o2({ reflect: true })], e3.prototype, "target", 2), n2([o2({ reflect: true })], e3.prototype, "rel", 2), e3;
}

// node_modules/@lit-labs/observers/mutation-controller.js
var t = class {
  constructor(t3, { target: s, config: i2, callback: h3, skipInitial: o3 }) {
    this.t = /* @__PURE__ */ new Set(), this.o = false, this.i = false, this.h = t3, null !== s && this.t.add(s ?? t3), this.l = i2, this.o = o3 ?? this.o, this.callback = h3, window.MutationObserver ? (this.u = new MutationObserver((t4) => {
      this.handleChanges(t4), this.h.requestUpdate();
    }), t3.addController(this)) : console.warn("MutationController error: browser does not support MutationObserver.");
  }
  handleChanges(t3) {
    this.value = this.callback?.(t3, this.u);
  }
  hostConnected() {
    for (const t3 of this.t)
      this.observe(t3);
  }
  hostDisconnected() {
    this.disconnect();
  }
  async hostUpdated() {
    const t3 = this.u.takeRecords();
    (t3.length || !this.o && this.i) && this.handleChanges(t3), this.i = false;
  }
  observe(t3) {
    this.t.add(t3), this.u.observe(t3, this.l), this.i = true, this.h.requestUpdate();
  }
  disconnect() {
    this.u.disconnect();
  }
};

// node_modules/@spectrum-web-components/shared/src/observe-slot-presence.js
var t2 = Symbol("slotContentIsPresent");
function ObserveSlotPresence(o3, s) {
  var l2;
  const r2 = Array.isArray(s) ? s : [s];
  class i2 extends o3 {
    constructor(...e3) {
      super(e3);
      this[l2] = /* @__PURE__ */ new Map();
      this.managePresenceObservedSlot = () => {
        let e4 = false;
        r2.forEach((n4) => {
          const a = !!this.querySelector(`:scope > ${n4}`), c = this[t2].get(n4) || false;
          e4 = e4 || c !== a, this[t2].set(n4, !!this.querySelector(`:scope > ${n4}`));
        }), e4 && this.updateComplete.then(() => {
          this.requestUpdate();
        });
      };
      new t(this, { config: { childList: true, subtree: true }, callback: () => {
        this.managePresenceObservedSlot();
      } }), this.managePresenceObservedSlot();
    }
    get slotContentIsPresent() {
      if (r2.length === 1)
        return this[t2].get(r2[0]) || false;
      throw new Error("Multiple selectors provided to `ObserveSlotPresence` use `getSlotContentPresence(selector: string)` instead.");
    }
    getSlotContentPresence(e3) {
      if (this[t2].has(e3))
        return this[t2].get(e3) || false;
      throw new Error(`The provided selector \`${e3}\` is not being observed.`);
    }
  }
  return l2 = t2, i2;
}

// node_modules/@spectrum-web-components/shared/src/observe-slot-text.js
import { property as x, queryAssignedNodes as T } from "/libs/features/spectrum-web-components/dist/base.js";
var g2 = Object.defineProperty;
var h2 = Object.getOwnPropertyDescriptor;
var u2 = (c, e3, s, o3) => {
  for (var t3 = o3 > 1 ? void 0 : o3 ? h2(e3, s) : e3, l2 = c.length - 1, a; l2 >= 0; l2--)
    (a = c[l2]) && (t3 = (o3 ? a(e3, s, t3) : a(t3)) || t3);
  return o3 && t3 && g2(e3, s, t3), t3;
};
var p = Symbol("assignedNodes");
function ObserveSlotText(c, e3, s = []) {
  var l2;
  const o3 = (a) => (f) => a.matches(f);
  class t3 extends c {
    constructor(...n4) {
      super(n4);
      this.slotHasContent = false;
      new t(this, { config: { characterData: true, subtree: true }, callback: (d3) => {
        for (const r2 of d3)
          if (r2.type === "characterData") {
            this.manageTextObservedSlot();
            return;
          }
      } });
    }
    manageTextObservedSlot() {
      if (!this[p])
        return;
      const n4 = [...this[p]].filter((d3) => {
        const r2 = d3;
        return r2.tagName ? !s.some(o3(r2)) : r2.textContent ? r2.textContent.trim() : false;
      });
      this.slotHasContent = n4.length > 0;
    }
    update(n4) {
      if (!this.hasUpdated) {
        const { childNodes: d3 } = this, r2 = [...d3].filter((m) => {
          const i2 = m;
          return i2.tagName ? s.some(o3(i2)) ? false : e3 ? i2.getAttribute("slot") === e3 : !i2.hasAttribute("slot") : i2.textContent ? i2.textContent.trim() : false;
        });
        this.slotHasContent = r2.length > 0;
      }
      super.update(n4);
    }
    firstUpdated(n4) {
      super.firstUpdated(n4), this.updateComplete.then(() => {
        this.manageTextObservedSlot();
      });
    }
  }
  return l2 = p, u2([x({ type: Boolean, attribute: false })], t3.prototype, "slotHasContent", 2), u2([T({ slot: e3, flatten: true })], t3.prototype, l2, 2), t3;
}

// node_modules/@spectrum-web-components/shared/src/platform.js
function n3(o3) {
  return typeof window != "undefined" && window.navigator != null ? o3.test(window.navigator.userAgent) : false;
}
function e2(o3) {
  return typeof window != "undefined" && window.navigator != null ? o3.test(window.navigator.platform) : false;
}
function isMac() {
  return e2(/^Mac/);
}
function isIPhone() {
  return e2(/^iPhone/);
}
function isIPad() {
  return e2(/^iPad/) || isMac() && navigator.maxTouchPoints > 1;
}
function isIOS() {
  return isIPhone() || isIPad();
}
function isAppleDevice() {
  return isMac() || isIOS();
}
function isWebKit() {
  return n3(/AppleWebKit/) && !isChrome();
}
function isChrome() {
  return n3(/Chrome/);
}
function isFirefox() {
  return n3(/Firefox/) && !isSeamonkey();
}
function isSeamonkey() {
  return n3(/Seamonkey/);
}
function isAndroid() {
  return n3(/Android/);
}

// node_modules/@spectrum-web-components/shared/src/reparent-children.js
function T2(o3, i2, l2 = []) {
  for (let e3 = 0; e3 < i2.length; ++e3) {
    const n4 = i2[e3], r2 = o3[e3], t3 = r2.parentElement || r2.getRootNode();
    l2[e3] && l2[e3](n4), t3 && t3 !== r2 && t3.replaceChild(n4, r2), delete o3[e3];
  }
  return i2;
}
var reparentChildren = (o3, i2, { position: l2, prepareCallback: e3 } = { position: "beforeend" }) => {
  let { length: n4 } = o3;
  if (n4 === 0)
    return () => o3;
  let r2 = 1, t3 = 0;
  (l2 === "afterbegin" || l2 === "afterend") && (r2 = -1, t3 = n4 - 1);
  const a = new Array(n4), c = new Array(n4), p2 = document.createComment("placeholder for reparented element");
  do {
    const d3 = o3[t3];
    e3 && (c[t3] = e3(d3)), a[t3] = p2.cloneNode();
    const m = d3.parentElement || d3.getRootNode();
    m && m !== d3 && m.replaceChild(a[t3], d3), i2.insertAdjacentElement(l2, d3), t3 += r2;
  } while (--n4 > 0);
  return function() {
    return T2(a, o3, c);
  };
};

// node_modules/@spectrum-web-components/shared/src/get-label-from-slot.js
var getLabelFromSlot = (r2, l2) => {
  if (r2)
    return null;
  const t3 = l2.assignedNodes().reduce((e3, n4) => n4.textContent ? e3 + n4.textContent : e3, "");
  return t3 ? t3.trim() : null;
};
export {
  FocusVisiblePolyfillMixin,
  Focusable,
  LikeAnchor,
  ObserveSlotPresence,
  ObserveSlotText,
  firstFocusableIn,
  firstFocusableSlottedIn,
  focusableSelector,
  getActiveElement,
  getLabelFromSlot,
  isAndroid,
  isAppleDevice,
  isChrome,
  isFirefox,
  isIOS,
  isIPad,
  isIPhone,
  isMac,
  isSeamonkey,
  isWebKit,
  reparentChildren,
  userFocusableSelector
};
